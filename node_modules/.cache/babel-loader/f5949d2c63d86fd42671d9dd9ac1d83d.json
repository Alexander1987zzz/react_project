{"ast":null,"code":"import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { Async } from './Async';\nimport { FieldFeedbacks } from './FieldFeedbacks';\nimport { FieldFeedbackType } from './FieldFeedbackType';\nimport { FieldFeedbackWhenValid } from './FieldFeedbackWhenValid';\nimport { FormWithConstraints } from './FormWithConstraints';\nexport class FieldFeedback extends React.Component {\n  constructor(props, context) {\n    super(props, context);\n\n    this.validate = input => {\n      const {\n        when\n      } = this.props;\n      const {\n        form,\n        fieldFeedbacks\n      } = this.context;\n      const field = form.fieldsStore.getField(input.name);\n      const validation = { ...this.state.validation\n      };\n\n      if (fieldFeedbacks.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacks.key) || fieldFeedbacks.props.stop === 'first-error' && field.hasErrors(fieldFeedbacks.key) || fieldFeedbacks.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacks.key) || fieldFeedbacks.props.stop === 'first-info' && field.hasInfos(fieldFeedbacks.key)) {\n        validation.show = undefined;\n      } else {\n        validation.show = false;\n\n        if (typeof when === 'function') {\n          validation.show = when(input.value);\n        } else if (typeof when === 'string') {\n          if (when === 'valid') {\n            validation.show = undefined;\n          } else {\n            const {\n              validity\n            } = input;\n\n            if (!validity.valid) {\n              if (when === '*') {\n                validation.show = true;\n              } else if (validity.badInput && when === 'badInput' || validity.patternMismatch && when === 'patternMismatch' || validity.rangeOverflow && when === 'rangeOverflow' || validity.rangeUnderflow && when === 'rangeUnderflow' || validity.stepMismatch && when === 'stepMismatch' || validity.tooLong && when === 'tooLong' || validity.tooShort && when === 'tooShort' || validity.typeMismatch && when === 'typeMismatch' || validity.valueMissing && when === 'valueMissing') {\n                validation.show = true;\n              }\n            }\n          }\n        } else {\n          throw new TypeError(`Invalid FieldFeedback 'when' type: ${typeof when}`);\n        }\n      }\n\n      field.addOrReplaceValidation(validation);\n      this.setState({\n        validation,\n        validationMessage: input.validationMessage\n      });\n      return validation;\n    };\n\n    this.fieldDidReset = field => {\n      if (field.name === this.context.fieldFeedbacks.fieldName) {\n        this.setState(prevState => ({\n          validation: { ...prevState.validation,\n            ...{\n              show: undefined\n            }\n          },\n          validationMessage: ''\n        }));\n      }\n    };\n\n    this.key = context.fieldFeedbacks.addFieldFeedback();\n    const {\n      error,\n      warning,\n      info,\n      when\n    } = props;\n    let type = FieldFeedbackType.Error;\n    if (when === 'valid') type = FieldFeedbackType.WhenValid;else if (warning) type = FieldFeedbackType.Warning;else if (info) type = FieldFeedbackType.Info;\n\n    if (type === FieldFeedbackType.WhenValid && (error || warning || info)) {\n      throw new Error('Cannot have an attribute (error, warning...) with FieldFeedback when=\"valid\"');\n    }\n\n    this.state = {\n      validation: {\n        key: this.key,\n        type,\n        show: undefined\n      },\n      validationMessage: ''\n    };\n  }\n\n  componentDidMount() {\n    const {\n      form,\n      fieldFeedbacks,\n      async\n    } = this.context;\n    if (async) async.addValidateFieldEventListener(this.validate);else fieldFeedbacks.addValidateFieldEventListener(this.validate);\n    form.addFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  componentWillUnmount() {\n    const {\n      form,\n      fieldFeedbacks,\n      async\n    } = this.context;\n    if (async) async.removeValidateFieldEventListener(this.validate);else fieldFeedbacks.removeValidateFieldEventListener(this.validate);\n    form.removeFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  render() {\n    const {\n      when,\n      error,\n      warning,\n      info,\n      className,\n      classes,\n      style,\n      children,\n      ...otherProps\n    } = this.props;\n    const {\n      validation,\n      validationMessage\n    } = this.state;\n    const fieldFeedbackClassName = classes[validation.type];\n    const classNames = className !== undefined ? `${className} ${fieldFeedbackClassName}` : fieldFeedbackClassName;\n\n    if (validation.type === FieldFeedbackType.WhenValid) {\n      return React.createElement(FieldFeedbackWhenValid, Object.assign({\n        \"data-feedback\": this.key,\n        style: style,\n        className: classNames\n      }, otherProps), children);\n    }\n\n    if (validation.show) {\n      const feedback = children !== undefined ? children : validationMessage;\n      return React.createElement(\"span\", Object.assign({\n        \"data-feedback\": this.key,\n        className: classNames,\n        style: {\n          display: 'block',\n          ...style\n        }\n      }, otherProps), feedback);\n    }\n\n    return null;\n  }\n\n}\nFieldFeedback.defaultProps = {\n  when: () => true,\n  classes: {\n    error: 'error',\n    warning: 'warning',\n    info: 'info',\n    whenValid: 'when-valid'\n  }\n};\nFieldFeedback.contextTypes = {\n  form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n  fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired,\n  async: PropTypes.instanceOf(Async)\n};","map":{"version":3,"sources":["../src/FieldFeedback.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { Async, AsyncChildContext } from './Async';\nimport { Field } from './Field';\nimport { FieldFeedbacks, FieldFeedbacksChildContext } from './FieldFeedbacks';\nimport { FieldFeedbackType } from './FieldFeedbackType';\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FieldFeedbackWhenValid } from './FieldFeedbackWhenValid';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { InputElement } from './InputElement';\nimport { Nullable } from './Nullable';\n\ntype WhenString =\n  | 'valid'\n  | '*'\n  | 'badInput' // input type=\"number\"\n  | 'patternMismatch' // pattern attribute\n  | 'rangeOverflow' // max attribute\n  | 'rangeUnderflow' // min attribute\n  | 'stepMismatch' // step attribute\n  | 'tooLong' // maxlength attribute\n  | 'tooShort' // minlength attribute\n  | 'typeMismatch' // input type=\"email\" or input type=\"url\"\n  | 'valueMissing'; // required attribute\ntype WhenFn = (value: string) => boolean;\ntype When = WhenString | WhenFn;\n\nexport interface FieldFeedbackClasses {\n  classes?: {\n    // FIXME Should not be declared \"?\" thanks to defaultProps?\n    [index: string]: string | undefined;\n    error?: string;\n    warning?: string;\n    info?: string;\n    whenValid?: string;\n  };\n}\n\nexport interface FieldFeedbackBaseProps {\n  when?: When; // FIXME Should not be declared \"?\" thanks to defaultProps?\n  error?: boolean;\n  warning?: boolean;\n  info?: boolean;\n}\n\nexport interface FieldFeedbackProps\n  extends FieldFeedbackBaseProps,\n    FieldFeedbackClasses,\n    React.HTMLAttributes<HTMLSpanElement> {}\n\ninterface FieldFeedbackState {\n  validation: FieldFeedbackValidation;\n\n  // Copy of input.validationMessage\n  // https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement\n  // https://www.w3.org/TR/html51/sec-forms.html#the-constraint-validation-api\n  validationMessage: string;\n}\n\n// Why Nullable? https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27973\nexport type FieldFeedbackContext = FormWithConstraintsChildContext &\n  FieldFeedbacksChildContext &\n  Partial<Nullable<AsyncChildContext>>;\n\nexport class FieldFeedback<\n  Props extends FieldFeedbackBaseProps = FieldFeedbackProps\n> extends React.Component<Props, FieldFeedbackState> {\n  static defaultProps: FieldFeedbackProps = {\n    when: () => true,\n    classes: {\n      error: 'error',\n      warning: 'warning',\n      info: 'info',\n      whenValid: 'when-valid'\n    }\n  };\n\n  static contextTypes: React.ValidationMap<FieldFeedbackContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired,\n    async: PropTypes.instanceOf(Async)\n  };\n  context!: FieldFeedbackContext;\n\n  // Tested: there is no conflict with React key prop (https://reactjs.org/docs/lists-and-keys.html)\n  readonly key: string; // '0.1', '1.0', '3.5'...\n\n  constructor(props: Props, context: FieldFeedbackContext) {\n    super(props, context);\n\n    this.key = context.fieldFeedbacks.addFieldFeedback();\n\n    const { error, warning, info, when } = props;\n\n    let type = FieldFeedbackType.Error; // Default is error\n    if (when === 'valid') type = FieldFeedbackType.WhenValid;\n    else if (warning) type = FieldFeedbackType.Warning;\n    else if (info) type = FieldFeedbackType.Info;\n\n    // Special case for when=\"valid\"\n    if (type === FieldFeedbackType.WhenValid && (error || warning || info)) {\n      throw new Error(\n        'Cannot have an attribute (error, warning...) with FieldFeedback when=\"valid\"'\n      );\n    }\n\n    // eslint-disable-next-line react/state-in-constructor\n    this.state = {\n      validation: {\n        key: this.key,\n        type,\n        show: undefined // undefined means the FieldFeedback was not checked\n      },\n      validationMessage: ''\n    };\n  }\n\n  componentDidMount() {\n    const { form, fieldFeedbacks, async } = this.context;\n\n    if (async) async.addValidateFieldEventListener(this.validate);\n    else fieldFeedbacks.addValidateFieldEventListener(this.validate);\n\n    form.addFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  componentWillUnmount() {\n    const { form, fieldFeedbacks, async } = this.context;\n\n    if (async) async.removeValidateFieldEventListener(this.validate);\n    else fieldFeedbacks.removeValidateFieldEventListener(this.validate);\n\n    form.removeFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  validate = (input: InputElement) => {\n    const { when } = this.props;\n    const { form, fieldFeedbacks } = this.context;\n\n    const field = form.fieldsStore.getField(input.name)!;\n\n    // Copy state so we don't modify it directly (use of setState() instead)\n    // eslint-disable-next-line react/no-access-state-in-setstate, react/destructuring-assignment\n    const validation = { ...this.state.validation };\n\n    if (\n      (fieldFeedbacks.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-error' && field.hasErrors(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-info' && field.hasInfos(fieldFeedbacks.key))\n    ) {\n      // Do nothing\n      validation.show = undefined; // undefined means the FieldFeedback was not checked\n    } else {\n      validation.show = false;\n\n      if (typeof when === 'function') {\n        validation.show = when(input.value);\n      } else if (typeof when === 'string') {\n        if (when === 'valid') {\n          // undefined => special case for when=\"valid\": always displayed, then FieldFeedbackWhenValid decides what to do\n          validation.show = undefined;\n        } else {\n          const { validity } = input;\n\n          if (!validity.valid) {\n            if (when === '*') {\n              validation.show = true;\n            } else if (\n              (validity.badInput && when === 'badInput') ||\n              (validity.patternMismatch && when === 'patternMismatch') ||\n              (validity.rangeOverflow && when === 'rangeOverflow') ||\n              (validity.rangeUnderflow && when === 'rangeUnderflow') ||\n              (validity.stepMismatch && when === 'stepMismatch') ||\n              (validity.tooLong && when === 'tooLong') ||\n              (validity.tooShort && when === 'tooShort') ||\n              (validity.typeMismatch && when === 'typeMismatch') ||\n              (validity.valueMissing && when === 'valueMissing')\n            ) {\n              validation.show = true;\n            }\n          }\n        }\n      } else {\n        throw new TypeError(`Invalid FieldFeedback 'when' type: ${typeof when}`);\n      }\n    }\n\n    field.addOrReplaceValidation(validation);\n\n    this.setState({\n      validation,\n      validationMessage: input.validationMessage\n    });\n\n    return validation;\n  };\n\n  fieldDidReset = (field: Field) => {\n    // Ignore the event if it's not for us\n    // eslint-disable-next-line react/destructuring-assignment\n    if (field.name === this.context.fieldFeedbacks.fieldName) {\n      this.setState(prevState => ({\n        validation: { ...prevState.validation, ...{ show: undefined } },\n        validationMessage: ''\n      }));\n    }\n  };\n\n  // Don't forget to update native/FieldFeedback.render()\n  render() {\n    const { when, error, warning, info, className, classes, style, children, ...otherProps } = (this\n      .props as unknown) as FieldFeedbackProps;\n    const { validation, validationMessage } = this.state;\n\n    const fieldFeedbackClassName = classes![validation.type]!;\n    const classNames =\n      className !== undefined ? `${className} ${fieldFeedbackClassName}` : fieldFeedbackClassName;\n\n    // Special case for when=\"valid\": always displayed, then FieldFeedbackWhenValid decides what to do\n    if (validation.type === FieldFeedbackType.WhenValid) {\n      return (\n        <FieldFeedbackWhenValid\n          data-feedback={this.key}\n          style={style}\n          className={classNames}\n          {...otherProps}\n        >\n          {children}\n        </FieldFeedbackWhenValid>\n      );\n    }\n\n    if (validation.show) {\n      const feedback = children !== undefined ? children : validationMessage;\n\n      // <span style=\"display: block\"> instead of <div> so FieldFeedback can be wrapped inside a <p>\n      return (\n        <span\n          data-feedback={this.key}\n          className={classNames}\n          style={{ display: 'block', ...style }}\n          {...otherProps}\n        >\n          {feedback}\n        </span>\n      );\n    }\n\n    return null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}