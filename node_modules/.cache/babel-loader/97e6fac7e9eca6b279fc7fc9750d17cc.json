{"ast":null,"code":"import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { assert } from './assert';\nimport { FieldsStore } from './FieldsStore';\nimport { InputElement } from './InputElement';\nimport { notUndefined } from './notUndefined';\nimport { withFieldDidResetEventEmitter } from './withFieldDidResetEventEmitter';\nimport { withFieldDidValidateEventEmitter } from './withFieldDidValidateEventEmitter';\nimport { withFieldWillValidateEventEmitter } from './withFieldWillValidateEventEmitter';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nclass FormWithConstraintsComponent extends React.PureComponent {}\n\nexport class FormWithConstraints extends withFieldDidResetEventEmitter(withFieldWillValidateEventEmitter(withFieldDidValidateEventEmitter(withValidateFieldEventEmitter(FormWithConstraintsComponent)))) {\n  constructor() {\n    super(...arguments);\n    this.form = null;\n    this.fieldsStore = new FieldsStore();\n    this.fieldFeedbacksKeyCounter = 0;\n  }\n\n  getChildContext() {\n    return {\n      form: this\n    };\n  }\n\n  computeFieldFeedbacksKey() {\n    return `${this.fieldFeedbacksKeyCounter++}`;\n  }\n\n  validateFields(...inputsOrNames) {\n    return this._validateFields(true, ...inputsOrNames);\n  }\n\n  validateForm() {\n    return this.validateFieldsWithoutFeedback();\n  }\n\n  validateFieldsWithoutFeedback(...inputsOrNames) {\n    return this._validateFields(false, ...inputsOrNames);\n  }\n\n  async _validateFields(forceValidateFields, ...inputsOrNames) {\n    const fields = new Array();\n    const inputs = this.normalizeInputs(...inputsOrNames);\n\n    for (let i = 0; i < inputs.length; i++) {\n      const input = inputs[i];\n      const field = await this.validateField(forceValidateFields, new InputElement(input), input);\n      if (field !== undefined) fields.push(field);\n    }\n\n    return fields;\n  }\n\n  async validateField(forceValidateFields, input, nativeInput) {\n    const fieldName = input.name;\n    const field = this.fieldsStore.getField(fieldName);\n\n    if (field === undefined) {} else if (forceValidateFields || !field.hasFeedbacks()) {\n      field.element = nativeInput;\n      field.clearValidations();\n      this.emitFieldWillValidateEvent(fieldName);\n      const arrayOfArrays = await this.emitValidateFieldEvent(input);\n      assert(JSON.stringify(arrayOfArrays.flat(Infinity).filter(fieldFeedback => notUndefined(fieldFeedback))) === JSON.stringify(field.validations), `FieldsStore does not match emitValidateFieldEvent() result, did the user changed the input rapidly?`);\n      this.emitFieldDidValidateEvent(field);\n    }\n\n    return field;\n  }\n\n  normalizeInputs(...inputsOrNames) {\n    let inputs;\n\n    if (inputsOrNames.length === 0) {\n      inputs = Array.from(this.form.querySelectorAll('[name]'));\n      inputs = inputs.filter(input => input.validity !== undefined);\n      inputs.filter(input => input.type !== 'checkbox' && input.type !== 'radio').map(input => input.name).forEach((name, index, self) => {\n        if (self.indexOf(name) !== index) {\n          throw new Error(`Multiple elements matching '[name=\"${name}\"]' inside the form`);\n        }\n      });\n    } else {\n      inputs = inputsOrNames.map(input => {\n        if (typeof input === 'string') {\n          const query = `[name=\"${input}\"]`;\n          const elements = Array.from(this.form.querySelectorAll(query));\n\n          if (elements.filter(el => el.validity === undefined).length > 0) {\n            throw new Error(`'${query}' should match an <input>, <select> or <textarea>`);\n          }\n\n          if (elements.filter(el => el.type !== 'checkbox' && el.type !== 'radio').length > 1) {\n            throw new Error(`Multiple elements matching '${query}' inside the form`);\n          }\n\n          const element = elements[0];\n\n          if (element === undefined) {\n            throw new Error(`Could not find field '${query}' inside the form`);\n          }\n\n          return element;\n        }\n\n        return input;\n      });\n    }\n\n    return inputs;\n  }\n\n  isValid() {\n    return this.fieldsStore.isValid();\n  }\n\n  hasFeedbacks() {\n    return this.fieldsStore.hasFeedbacks();\n  }\n\n  reset() {\n    return this.resetFields();\n  }\n\n  resetFields(...inputsOrNames) {\n    const fields = new Array();\n    const inputs = this.normalizeInputs(...inputsOrNames);\n    inputs.forEach(input => {\n      const field = this.resetField(new InputElement(input));\n      if (field !== undefined) fields.push(field);\n    });\n    return fields;\n  }\n\n  resetField(input) {\n    const fieldName = input.name;\n    const field = this.fieldsStore.getField(fieldName);\n\n    if (field === undefined) {} else {\n      field.clearValidations();\n      this.emitFieldDidResetEvent(field);\n    }\n\n    return field;\n  }\n\n  render() {\n    return React.createElement(\"form\", Object.assign({\n      ref: form => this.form = form\n    }, this.props));\n  }\n\n}\nFormWithConstraints.childContextTypes = {\n  form: PropTypes.instanceOf(FormWithConstraints).isRequired\n};","map":{"version":3,"sources":["../src/FormWithConstraints.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { assert } from './assert';\nimport { Field } from './Field';\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FieldsStore } from './FieldsStore';\nimport { HTMLInput, IHTMLInput, InputElement, TextInput } from './InputElement';\nimport { notUndefined } from './notUndefined';\nimport { withFieldDidResetEventEmitter } from './withFieldDidResetEventEmitter';\nimport { withFieldDidValidateEventEmitter } from './withFieldDidValidateEventEmitter';\nimport { withFieldWillValidateEventEmitter } from './withFieldWillValidateEventEmitter';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nexport interface FormWithConstraintsChildContext {\n  form: FormWithConstraints;\n}\n\nexport interface FormWithConstraintsProps extends React.FormHTMLAttributes<HTMLFormElement> {}\n\nclass FormWithConstraintsComponent extends React.PureComponent<FormWithConstraintsProps> {}\nexport class FormWithConstraints\n  extends withFieldDidResetEventEmitter(\n    withFieldWillValidateEventEmitter(\n      withFieldDidValidateEventEmitter(\n        withValidateFieldEventEmitter<\n          // FieldFeedback returns FieldFeedbackValidation\n          // Async returns FieldFeedbackValidation[] | undefined\n          // FieldFeedbacks returns (FieldFeedbackValidation | undefined)[] | undefined\n          FieldFeedbackValidation | (FieldFeedbackValidation | undefined)[] | undefined,\n          typeof FormWithConstraintsComponent\n        >(FormWithConstraintsComponent)\n      )\n    )\n  )\n  implements React.ChildContextProvider<FormWithConstraintsChildContext> {\n  static childContextTypes: React.ValidationMap<FormWithConstraintsChildContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired\n  };\n  getChildContext(): FormWithConstraintsChildContext {\n    return {\n      form: this\n    };\n  }\n\n  // Could be named innerRef instead, https://github.com/ant-design/ant-design/issues/5489#issuecomment-332208652\n  private form: HTMLFormElement | null = null;\n\n  fieldsStore = new FieldsStore();\n\n  private fieldFeedbacksKeyCounter = 0;\n  computeFieldFeedbacksKey() {\n    return `${this.fieldFeedbacksKeyCounter++}`;\n  }\n\n  /**\n   * Validates the given fields, either HTMLInputElements or field names.\n   * If called without arguments, validates all fields ($('[name]')).\n   */\n  validateFields(...inputsOrNames: Array<IHTMLInput | string>) {\n    return this._validateFields(/* forceValidateFields */ true, ...inputsOrNames);\n  }\n\n  // TODO To be removed in the future?\n  validateForm() {\n    return this.validateFieldsWithoutFeedback();\n  }\n\n  /**\n   * Validates fields without feedback only.\n   */\n  validateFieldsWithoutFeedback(...inputsOrNames: Array<IHTMLInput | string>) {\n    return this._validateFields(/* forceValidateFields */ false, ...inputsOrNames);\n  }\n\n  private async _validateFields(\n    forceValidateFields: boolean,\n    ...inputsOrNames: Array<IHTMLInput | string>\n  ) {\n    const fields = new Array<Readonly<Field>>();\n\n    const inputs = this.normalizeInputs(...inputsOrNames);\n\n    for (let i = 0; i < inputs.length; i++) {\n      const input = inputs[i];\n      // eslint-disable-next-line no-await-in-loop\n      const field = await this.validateField(\n        forceValidateFields,\n        new InputElement(input),\n        input as HTMLInput | TextInput\n      );\n      if (field !== undefined) fields.push(field);\n    }\n\n    return fields;\n  }\n\n  private async validateField(\n    forceValidateFields: boolean,\n    input: InputElement,\n\n    // We need to pass the native input separately instead of it being a property of InputElement\n    // otherwise react-form-with-constraints-native unit tests will crash\n    nativeInput: HTMLInput | TextInput\n  ) {\n    const fieldName = input.name;\n    const field = this.fieldsStore.getField(fieldName);\n\n    if (field === undefined) {\n      // Means the field (<input name=\"username\">) does not have a FieldFeedbacks\n      // so let's ignore this field\n    } else if (forceValidateFields || !field.hasFeedbacks()) {\n      field.element = nativeInput as HTMLInput | TextInput;\n      field.clearValidations();\n\n      this.emitFieldWillValidateEvent(fieldName);\n\n      const arrayOfArrays = await this.emitValidateFieldEvent(input);\n\n      // Internal check that everything is OK\n      // Can be temporary out of sync if the user rapidly change the input, in this case:\n      // emitFieldWillValidateEvent() returns the result of the first change while the store already contains the final validations\n      assert(\n        JSON.stringify(\n          (arrayOfArrays.flat(Infinity) as (\n            | FieldFeedbackValidation\n            | undefined\n          )[]).filter(fieldFeedback => notUndefined(fieldFeedback))\n        ) /* validationsFromEmitValidateFieldEvent */ ===\n          JSON.stringify(field.validations) /* validationsFromStore */,\n        `FieldsStore does not match emitValidateFieldEvent() result, did the user changed the input rapidly?`\n      );\n\n      this.emitFieldDidValidateEvent(field);\n    }\n\n    return field;\n  }\n\n  // If called without arguments, returns all fields ($('[name]'))\n  // Returns the inputs in the same order they were given\n  protected normalizeInputs(...inputsOrNames: Array<IHTMLInput | string>) {\n    let inputs;\n\n    if (inputsOrNames.length === 0) {\n      // [name] matches <input name=\"...\">, <select name=\"...\">, <button name=\"...\">, ...\n      // [Convert JavaScript NodeList to Array?](https://stackoverflow.com/a/33822526/990356)\n      // [...NodeList] vs Array.from(NodeList): the latter doesn't need downlevelIteration with IE\n      // eslint-disable-next-line unicorn/prefer-spread\n      inputs = Array.from(this.form!.querySelectorAll<HTMLInputElement>('[name]'));\n\n      // Remove elements without ValidityState, example:\n      // <iframe src=\"https://www.google.com/recaptcha...\" name=\"a-49ekipqfmwsv\">\n      // Without this check, possible crash inside InputElement is \"TypeError: Cannot read property 'badInput' of undefined\"\n      //\n      // ValidityState is available for (lib.dom.d.ts):\n      // HTMLButtonElement, HTMLFieldSetElement, HTMLInputElement, HTMLObjectElement,\n      // HTMLOutputElement, HTMLSelectElement, HTMLTextAreaElement\n      //\n      // ValidityState is supported by IE >= 10\n      inputs = inputs.filter(input => input.validity !== undefined);\n\n      // Check we have unique names\n      inputs\n        .filter(input => input.type !== 'checkbox' && input.type !== 'radio')\n        .map(input => input.name)\n        .forEach((name, index, self) => {\n          if (self.indexOf(name) !== index) {\n            throw new Error(`Multiple elements matching '[name=\"${name}\"]' inside the form`);\n          }\n        });\n    } else {\n      inputs = inputsOrNames.map(input => {\n        if (typeof input === 'string') {\n          const query = `[name=\"${input}\"]`;\n\n          // [...NodeList] vs Array.from(NodeList): the latter doesn't need downlevelIteration with IE\n          // eslint-disable-next-line unicorn/prefer-spread\n          const elements = Array.from(this.form!.querySelectorAll<HTMLInputElement>(query));\n\n          // Checks\n\n          if (elements.filter(el => el.validity === undefined).length > 0) {\n            // Should not match something like\n            // <iframe src=\"https://www.google.com/recaptcha...\" name=\"a-49ekipqfmwsv\">\n            throw new Error(`'${query}' should match an <input>, <select> or <textarea>`);\n          }\n          if (elements.filter(el => el.type !== 'checkbox' && el.type !== 'radio').length > 1) {\n            throw new Error(`Multiple elements matching '${query}' inside the form`);\n          }\n          const element = elements[0];\n          if (element === undefined) {\n            throw new Error(`Could not find field '${query}' inside the form`);\n          }\n\n          return element;\n        }\n\n        return input;\n      });\n    }\n\n    return inputs;\n  }\n\n  // More like seemsToBeValid(): return true if fields are untouched\n  isValid() {\n    return this.fieldsStore.isValid();\n  }\n\n  hasFeedbacks() {\n    return this.fieldsStore.hasFeedbacks();\n  }\n\n  // TODO To be removed in the future?\n  reset() {\n    return this.resetFields();\n  }\n\n  resetFields(...inputsOrNames: Array<IHTMLInput | string>) {\n    const fields = new Array<Readonly<Field>>();\n\n    const inputs = this.normalizeInputs(...inputsOrNames);\n    inputs.forEach(input => {\n      const field = this.resetField(new InputElement(input));\n      if (field !== undefined) fields.push(field);\n    });\n\n    return fields;\n  }\n\n  private resetField(input: InputElement) {\n    const fieldName = input.name;\n    const field = this.fieldsStore.getField(fieldName);\n\n    if (field === undefined) {\n      // Means the field (<input name=\"username\">) does not have a FieldFeedbacks\n      // so let's ignore this field\n    } else {\n      field.clearValidations();\n      this.emitFieldDidResetEvent(field);\n    }\n\n    return field;\n  }\n\n  render() {\n    return <form ref={form => (this.form = form)} {...this.props} />;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}