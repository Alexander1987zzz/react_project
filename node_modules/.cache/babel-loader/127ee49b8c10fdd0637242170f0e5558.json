{"ast":null,"code":"import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { FormWithConstraints } from './FormWithConstraints';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nclass FieldFeedbacksComponent extends React.PureComponent {}\n\nexport class FieldFeedbacks extends withValidateFieldEventEmitter(FieldFeedbacksComponent) {\n  constructor(props, context) {\n    super(props, context);\n    this.fieldFeedbackKeyCounter = 0;\n\n    this.validate = async input => {\n      const {\n        form,\n        fieldFeedbacks: fieldFeedbacksParent\n      } = this.context;\n      let validations;\n\n      if (input.name === this.fieldName) {\n        const field = form.fieldsStore.getField(this.fieldName);\n\n        if (fieldFeedbacksParent && (fieldFeedbacksParent.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacksParent.key) || fieldFeedbacksParent.props.stop === 'first-error' && field.hasErrors(fieldFeedbacksParent.key) || fieldFeedbacksParent.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacksParent.key) || fieldFeedbacksParent.props.stop === 'first-info' && field.hasInfos(fieldFeedbacksParent.key))) {} else {\n          validations = await this._validate(input);\n        }\n      }\n\n      return validations;\n    };\n\n    const {\n      form,\n      fieldFeedbacks: fieldFeedbacksParent\n    } = context;\n    this.key = fieldFeedbacksParent ? fieldFeedbacksParent.computeFieldFeedbackKey() : form.computeFieldFeedbacksKey();\n\n    if (fieldFeedbacksParent) {\n      this.fieldName = fieldFeedbacksParent.fieldName;\n\n      if (props.for !== undefined) {\n        throw new Error(\"FieldFeedbacks cannot have a parent and a 'for' prop\");\n      }\n    } else {\n      if (props.for === undefined) {\n        throw new Error(\"FieldFeedbacks cannot be without parent and without 'for' prop\");\n      } else {\n        this.fieldName = props.for;\n      }\n    }\n  }\n\n  getChildContext() {\n    return {\n      fieldFeedbacks: this\n    };\n  }\n\n  computeFieldFeedbackKey() {\n    return `${this.key}.${this.fieldFeedbackKeyCounter++}`;\n  }\n\n  addFieldFeedback() {\n    return this.computeFieldFeedbackKey();\n  }\n\n  componentDidMount() {\n    const {\n      form,\n      fieldFeedbacks: fieldFeedbacksParent\n    } = this.context;\n    form.fieldsStore.addField(this.fieldName);\n    const parent = fieldFeedbacksParent || form;\n    parent.addValidateFieldEventListener(this.validate);\n  }\n\n  componentWillUnmount() {\n    const {\n      form,\n      fieldFeedbacks: fieldFeedbacksParent\n    } = this.context;\n    form.fieldsStore.removeField(this.fieldName);\n    const parent = fieldFeedbacksParent || form;\n    parent.removeValidateFieldEventListener(this.validate);\n  }\n\n  async _validate(input) {\n    const arrayOfArrays = await this.emitValidateFieldEvent(input);\n    const validations = arrayOfArrays.flat(Infinity);\n    return validations;\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    return children !== undefined ? children : null;\n  }\n\n}\nFieldFeedbacks.defaultProps = {\n  stop: 'first-error'\n};\nFieldFeedbacks.contextTypes = {\n  form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n  fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks)\n};\nFieldFeedbacks.childContextTypes = {\n  fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired\n};","map":{"version":3,"sources":["../src/FieldFeedbacks.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { InputElement } from './InputElement';\nimport { Nullable } from './Nullable';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nexport interface FieldFeedbacksProps {\n  for?: string;\n\n  /**\n   * first-* => stops on the first * encountered\n   * no => shows everything\n   * Default is 'first-error'\n   */\n  stop: 'first' | 'first-error' | 'first-warning' | 'first-info' | 'no';\n}\n\n// Why Nullable? https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27973\nexport type FieldFeedbacksContext = FormWithConstraintsChildContext &\n  Partial<Nullable<FieldFeedbacksChildContext>>;\n\nexport interface FieldFeedbacksChildContext {\n  fieldFeedbacks: FieldFeedbacks;\n}\n\nclass FieldFeedbacksComponent extends React.PureComponent<FieldFeedbacksProps> {}\nexport class FieldFeedbacks\n  extends withValidateFieldEventEmitter<\n    // FieldFeedback returns FieldFeedbackValidation\n    // Async returns FieldFeedbackValidation[] | undefined\n    // FieldFeedbacks returns (FieldFeedbackValidation | undefined)[]\n    FieldFeedbackValidation | (FieldFeedbackValidation | undefined)[] | undefined,\n    typeof FieldFeedbacksComponent\n  >(FieldFeedbacksComponent)\n  implements React.ChildContextProvider<FieldFeedbacksChildContext> {\n  static defaultProps: FieldFeedbacksProps = {\n    stop: 'first-error'\n  };\n\n  static contextTypes: React.ValidationMap<FieldFeedbacksContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks)\n  };\n  context!: FieldFeedbacksContext;\n\n  static childContextTypes: React.ValidationMap<FieldFeedbacksChildContext> = {\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired\n  };\n  getChildContext(): FieldFeedbacksChildContext {\n    return {\n      fieldFeedbacks: this\n    };\n  }\n\n  // Tested: there is no conflict with React key prop (https://reactjs.org/docs/lists-and-keys.html)\n  readonly key: string; // '0', '1', '2'...\n\n  readonly fieldName: string; // Instead of reading props each time\n\n  constructor(props: FieldFeedbacksProps, context: FieldFeedbacksContext) {\n    super(props, context);\n\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = context;\n\n    this.key = fieldFeedbacksParent\n      ? fieldFeedbacksParent.computeFieldFeedbackKey()\n      : form.computeFieldFeedbacksKey();\n\n    if (fieldFeedbacksParent) {\n      this.fieldName = fieldFeedbacksParent.fieldName;\n      if (props.for !== undefined) {\n        throw new Error(\"FieldFeedbacks cannot have a parent and a 'for' prop\");\n      }\n    } else {\n      if (props.for === undefined) {\n        throw new Error(\"FieldFeedbacks cannot be without parent and without 'for' prop\");\n      } else {\n        this.fieldName = props.for;\n      }\n    }\n  }\n\n  private fieldFeedbackKeyCounter = 0;\n  computeFieldFeedbackKey() {\n    return `${this.key}.${this.fieldFeedbackKeyCounter++}`;\n  }\n\n  addFieldFeedback() {\n    return this.computeFieldFeedbackKey();\n  }\n\n  componentDidMount() {\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;\n\n    form.fieldsStore.addField(this.fieldName);\n\n    const parent = fieldFeedbacksParent || form;\n    parent.addValidateFieldEventListener(this.validate);\n  }\n\n  componentWillUnmount() {\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;\n\n    form.fieldsStore.removeField(this.fieldName);\n\n    const parent = fieldFeedbacksParent || form;\n    parent.removeValidateFieldEventListener(this.validate);\n  }\n\n  validate = async (input: InputElement) => {\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;\n\n    let validations;\n\n    // Ignore the event if it's not for us\n    if (input.name === this.fieldName) {\n      const field = form.fieldsStore.getField(this.fieldName)!;\n\n      // prettier-ignore\n      if (fieldFeedbacksParent && (\n          fieldFeedbacksParent.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacksParent.key) ||\n          fieldFeedbacksParent.props.stop === 'first-error' && field.hasErrors(fieldFeedbacksParent.key) ||\n          fieldFeedbacksParent.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacksParent.key) ||\n          fieldFeedbacksParent.props.stop === 'first-info' && field.hasInfos(fieldFeedbacksParent.key))) {\n        // Do nothing\n      } else {\n        validations = await this._validate(input);\n      }\n    }\n\n    return validations;\n  };\n\n  async _validate(input: InputElement) {\n    const arrayOfArrays = await this.emitValidateFieldEvent(input);\n    const validations = arrayOfArrays.flat(Infinity) as (FieldFeedbackValidation | undefined)[];\n    return validations;\n  }\n\n  render() {\n    const { children } = this.props;\n    // https://codepen.io/tkrotoff/pen/yzKKdB\n    return children !== undefined ? children : null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}