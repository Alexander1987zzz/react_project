{"ast":null,"code":"import { assert } from './assert';\nexport class EventEmitter {\n  constructor() {\n    this.listeners = new Map();\n  }\n\n  emitSync(eventName, ...args) {\n    const listeners = this.getListeners(eventName);\n    const ret = new Array();\n    listeners.forEach(listener => ret.push(listener(...args)));\n    return ret;\n  }\n\n  async emitAsync(eventName, ...args) {\n    const listeners = this.getListeners(eventName);\n    const ret = new Array();\n\n    for (let i = 0; i < listeners.length; i++) {\n      ret.push(await listeners[i](...args));\n    }\n\n    return ret;\n  }\n\n  getListeners(eventName) {\n    const listeners = this.listeners.get(eventName);\n\n    if (listeners !== undefined) {\n      assert(listeners.length > 0, `No listener for event '${eventName}'`);\n      return listeners;\n    }\n\n    return [];\n  }\n\n  addListener(eventName, listener) {\n    if (!this.listeners.has(eventName)) this.listeners.set(eventName, []);\n    const listeners = this.listeners.get(eventName);\n    assert(!listeners.includes(listener), `Listener already added for event '${eventName}'`);\n    listeners.push(listener);\n  }\n\n  removeListener(eventName, listener) {\n    const listeners = this.listeners.get(eventName);\n    assert(listeners !== undefined, `Unknown event '${eventName}'`);\n    const index = listeners.lastIndexOf(listener);\n    assert(index > -1, `Listener not found for event '${eventName}'`);\n    listeners.splice(index, 1);\n    if (listeners.length === 0) this.listeners.delete(eventName);\n  }\n\n}","map":{"version":3,"sources":["../src/EventEmitter.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,UAAvB;AAMA,OAAM,MAAO,YAAP,CAAmB;AAAzB,EAAA,WAAA,GAAA;AACE,SAAA,SAAA,GAAY,IAAI,GAAJ,EAAZ;AA0DD;;AAxDC,EAAA,QAAQ,CAAC,SAAD,EAAoB,GAAG,IAAvB,EAAyC;AAC/C,UAAM,SAAS,GAAG,KAAK,YAAL,CAAkB,SAAlB,CAAlB;AACA,UAAM,GAAG,GAAG,IAAI,KAAJ,EAAZ;AACA,IAAA,SAAS,CAAC,OAAV,CAAkB,QAAQ,IAAI,GAAG,CAAC,IAAJ,CAAS,QAAQ,CAAC,GAAG,IAAJ,CAAjB,CAA9B;AACA,WAAO,GAAP;AACD;;AAEc,QAAT,SAAS,CAAC,SAAD,EAAoB,GAAG,IAAvB,EAAyC;AACtD,UAAM,SAAS,GAAG,KAAK,YAAL,CAAkB,SAAlB,CAAlB;AACA,UAAM,GAAG,GAAG,IAAI,KAAJ,EAAZ;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AAQzC,MAAA,GAAG,CAAC,IAAJ,CAAS,MAAM,SAAS,CAAC,CAAD,CAAT,CAAa,GAAG,IAAhB,CAAf;AACD;;AACD,WAAO,GAAP;AACD;;AAEO,EAAA,YAAY,CAAC,SAAD,EAAkB;AACpC,UAAM,SAAS,GAAG,KAAK,SAAL,CAAe,GAAf,CAAmB,SAAnB,CAAlB;;AAKA,QAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,MAAA,MAAM,CAAC,SAAS,CAAC,MAAV,GAAmB,CAApB,EAAuB,0BAA0B,SAAS,GAA1D,CAAN;AACA,aAAO,SAAP;AACD;;AACD,WAAO,EAAP;AACD;;AAED,EAAA,WAAW,CAAC,SAAD,EAAoB,QAApB,EAAwE;AACjF,QAAI,CAAC,KAAK,SAAL,CAAe,GAAf,CAAmB,SAAnB,CAAL,EAAoC,KAAK,SAAL,CAAe,GAAf,CAAmB,SAAnB,EAA8B,EAA9B;AACpC,UAAM,SAAS,GAAG,KAAK,SAAL,CAAe,GAAf,CAAmB,SAAnB,CAAlB;AACA,IAAA,MAAM,CAAC,CAAC,SAAS,CAAC,QAAV,CAAmB,QAAnB,CAAF,EAAgC,qCAAqC,SAAS,GAA9E,CAAN;AACA,IAAA,SAAS,CAAC,IAAV,CAAe,QAAf;AACD;;AAKD,EAAA,cAAc,CAAC,SAAD,EAAoB,QAApB,EAAwE;AACpF,UAAM,SAAS,GAAG,KAAK,SAAL,CAAe,GAAf,CAAmB,SAAnB,CAAlB;AACA,IAAA,MAAM,CAAC,SAAS,KAAK,SAAf,EAA0B,kBAAkB,SAAS,GAArD,CAAN;AAEA,UAAM,KAAK,GAAG,SAAS,CAAC,WAAV,CAAsB,QAAtB,CAAd;AACA,IAAA,MAAM,CAAC,KAAK,GAAG,CAAC,CAAV,EAAa,iCAAiC,SAAS,GAAvD,CAAN;AACA,IAAA,SAAS,CAAC,MAAV,CAAiB,KAAjB,EAAwB,CAAxB;AAEA,QAAI,SAAS,CAAC,MAAV,KAAqB,CAAzB,EAA4B,KAAK,SAAL,CAAe,MAAf,CAAsB,SAAtB;AAC7B;;AA1DsB","sourcesContent":["import { assert } from './assert';\n\n// FIXME [Proposal: Variadic Kinds -- Give specific types to variadic functions](https://github.com/Microsoft/TypeScript/issues/5453)\n\ntype Listener<Args extends any[], ReturnType> = (...args: Args) => ReturnType | Promise<ReturnType>;\n\nexport class EventEmitter<ListenerArgs extends any[], ListenerReturnType> {\n  listeners = new Map<string, Listener<ListenerArgs, ListenerReturnType>[]>();\n\n  emitSync(eventName: string, ...args: ListenerArgs) {\n    const listeners = this.getListeners(eventName);\n    const ret = new Array<ListenerReturnType>();\n    listeners.forEach(listener => ret.push(listener(...args) as ListenerReturnType));\n    return ret;\n  }\n\n  async emitAsync(eventName: string, ...args: ListenerArgs) {\n    const listeners = this.getListeners(eventName);\n    const ret = new Array<ListenerReturnType>();\n    for (let i = 0; i < listeners.length; i++) {\n      // Why await? Two cases:\n      // - listener does not return a Promise:\n      //   => await changes nothing: the next listener call happens when the current one is done\n      // - listener returns a Promise:\n      //   => wait for the listener call to finish (e.g listeners are executed in sequence),\n      //      without we would call each listener without waiting for their results\n      // eslint-disable-next-line no-await-in-loop\n      ret.push(await listeners[i](...args));\n    }\n    return ret;\n  }\n\n  private getListeners(eventName: string) {\n    const listeners = this.listeners.get(eventName);\n\n    // Assert disabled: an event can be emitted even without listeners\n    //assert(listeners !== undefined, `Unknown event '${eventName}'`);\n\n    if (listeners !== undefined) {\n      assert(listeners.length > 0, `No listener for event '${eventName}'`);\n      return listeners;\n    }\n    return [];\n  }\n\n  addListener(eventName: string, listener: Listener<ListenerArgs, ListenerReturnType>) {\n    if (!this.listeners.has(eventName)) this.listeners.set(eventName, []);\n    const listeners = this.listeners.get(eventName)!;\n    assert(!listeners.includes(listener), `Listener already added for event '${eventName}'`);\n    listeners.push(listener);\n  }\n\n  // [\"removeListener() will remove, at most, one instance of a listener from the listener array.\n  // If any single listener has been added multiple times to the listener array for the specified eventName,\n  // then removeListener() must be called multiple times to remove each instance.\"](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener)\n  removeListener(eventName: string, listener: Listener<ListenerArgs, ListenerReturnType>) {\n    const listeners = this.listeners.get(eventName);\n    assert(listeners !== undefined, `Unknown event '${eventName}'`);\n\n    const index = listeners.lastIndexOf(listener);\n    assert(index > -1, `Listener not found for event '${eventName}'`);\n    listeners.splice(index, 1);\n\n    if (listeners.length === 0) this.listeners.delete(eventName);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}